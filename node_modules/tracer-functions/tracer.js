// tracer.js
// Dynamically import chalk
let chalk;
(async () => {
    chalk = (await import('chalk')).default;
    // You might want to delay some initialization or calls until chalk is loaded
    // For simple console logging, this often works fine because chalk is usually
    // needed before much else happens.
})();


let _indentLevel = 0;
const _indentSize = 2; // Spaces per indent level

// Emojis for different log types (only used in REGULAR mode now)
const EMOJI_CALL = '‚û°Ô∏è';
const EMOJI_RETURN = '‚¨ÖÔ∏è';
const EMOJI_ERROR = '‚ùå';
const EMOJI_WARN = '‚ö†Ô∏è';
const EMOJI_INFO = 'üí°';

// --- TRACER MODES ---
const TRACER_MODE = {
    REGULAR: 'regular', // Default human-readable format with emojis and colors
    TEXT: 'text',       // Plain text, minimal output
    JSON: 'json',       // Raw JSON output for programmatic parsing
    TREE: 'tree'        // Tree-like visual with connecting lines
};

let _currentMode = TRACER_MODE.REGULAR; // Default mode
let _enableTracing = true; // Global toggle for tracing

// Store trace events for JSON/Tree modes
const _traceEvents = [];

// Tree mode specific:
const _callStack = []; // To manage the tree structure
const _treeLines = []; // To store lines for tree output

function setMode(mode) {
    if (Object.values(TRACER_MODE).includes(mode)) {
        _currentMode = mode;
        // Use chalk for tracer's own messages, even in text mode, for clarity
        // Ensure chalk is loaded before using it
        if (chalk) {
            console.log(chalk.gray(`[TRACER] Mode set to: ${mode}`));
        } else {
            console.log(`[TRACER] Mode set to: ${mode}`); // Fallback if chalk not yet loaded
        }
    } else {
        if (chalk) {
            console.warn(chalk.yellow(`${EMOJI_WARN} [TRACER] Invalid mode: ${mode}. Keeping current mode: ${_currentMode}`));
        } else {
            console.warn(`[TRACER] Invalid mode: ${mode}. Keeping current mode: ${_currentMode}`); // Fallback
        }
    }
}

function enableTracing(enable = false,log = false) {
    _enableTracing = enable;
    if (chalk && log) {
        console.log(chalk.gray(`[TRACER] Tracing ${enable ? 'enabled' : 'disabled'}`));
    } else if (log) {
        console.log(`[TRACER] Tracing ${enable ? 'enabled' : 'disabled'}`); // Fallback
    }
}

function resetTracer() {
    _indentLevel = 0;
    _traceEvents.length = 0; // Clear array
    _callStack.length = 0;
    _treeLines.length = 0;
}

function getIndent(level = _indentLevel) {
    return ' '.repeat(level * _indentSize);
}

// Helper for tree mode
function getTreePrefix() {
    let prefix = '';
    for (let i = 0; i < _callStack.length - 1; i++) {
        prefix += _callStack[i].lastChild ? '    ' : '‚îÇ   ';
    }
    prefix += _callStack.length > 0 ? (_callStack[_callStack.length - 1].lastChild ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ') : '';
    return prefix;
}

function serializeArgs(args) {
    return args.map((arg, index) => {
        try {
            const str = JSON.stringify(arg);
            return {
                [`arg${index}`]: str.length > 100 ? str.substring(0, 97) + '...' : arg
            };
        } catch (e) {
            return { [`arg${index}`]: '[Unstringifiable Object]' };
        }
    }).reduce((acc, current) => ({ ...acc, ...current }), {}); // Flatten array of objects
}

function serializeArgsPlain(args) {
    return args.map((arg, index) => {
        try {
            const str = JSON.stringify(arg);
            return `${index}: ${str.length > 50 ? str.substring(0, 47) + '...' : str}`;
        } catch (e) {
            return `${index}: [Unstringifiable Object]`;
        }
    }).join(', ');
}


function serializeReturnValue(returnValue) {
    try {
        const str = JSON.stringify(returnValue);
        return str.length > 100 ? str.substring(0, 97) + '...' : returnValue;
    } catch (e) {
        return '[Unstringifiable Return Value]';
    }
}

function serializeReturnValuePlain(returnValue) {
    try {
        const str = JSON.stringify(returnValue);
        return str.length > 50 ? str.substring(0, 47) + '...' : str;
    } catch (e) {
        return '[Unstringifiable Return Value]';
    }
}


/**
 * Wraps a function to add logging for its entry and exit.
 */
function wrapFunction(originalFn, functionName, filePath, lineNum) {
    if (typeof originalFn !== 'function') {
        if (_enableTracing) {
            if (chalk) {
                console.warn(chalk.yellow(`${EMOJI_WARN} [TRACER] Cannot wrap non-function: ${functionName}`));
            } else {
                console.warn(`[TRACER] Cannot wrap non-function: ${functionName}`);
            }
        }
        return originalFn;
    }

    const fileName = filePath.split('/').pop();

    function tracedFunction(...args) {
        if (!_enableTracing) {
            return originalFn.apply(this, args);
        }

        const entryHrTime = process.hrtime.bigint();

        if (_currentMode === TRACER_MODE.REGULAR) {
            const argStrings = serializeArgs(args);
            // Ensure chalk is loaded before using it
            if (chalk) {
                console.log(chalk.blue(`${getIndent()}${EMOJI_CALL} ${functionName} (${fileName}:${lineNum}), args: ${JSON.stringify(argStrings)}`));
            } else {
                console.log(`${getIndent()}${EMOJI_CALL} ${functionName} (${fileName}:${lineNum}), args: ${JSON.stringify(argStrings)}`);
            }

        } else if (_currentMode === TRACER_MODE.TEXT) {
            const argStringsPlain = serializeArgsPlain(args);
            console.log(`${getIndent()}CALL ${functionName} (${fileName}:${lineNum}), args: ${argStringsPlain}`);
        } else if (_currentMode === TRACER_MODE.TREE) {
            if (chalk) {
                _treeLines.push(getTreePrefix() + chalk.blue(`${EMOJI_CALL} ${functionName} (${fileName}:${lineNum})`));
            } else {
                _treeLines.push(getTreePrefix() + `${EMOJI_CALL} ${functionName} (${fileName}:${lineNum})`);
            }
            _callStack.push({ name: functionName, lastChild: false, children: [] });
        }

        const traceEvent = {
            type: 'call',
            function: functionName,
            file: fileName,
            filePath: filePath,
            line: lineNum,
            args: serializeArgs(args),
            timestamp: Date.now(),
            level: _indentLevel,
            children: []
        };
        _traceEvents.push(traceEvent);


        _indentLevel++;

        let returnValue;
        let threwError = false;
        let errorDetails = null;

        try {
            returnValue = originalFn.apply(this, args);
        } catch (e) {
            returnValue = e;
            threwError = true;
            errorDetails = { message: e.message, stack: e.stack };
        } finally {
            _indentLevel--;
            const exitHrTime = process.hrtime.bigint();
            const durationMs = Number(exitHrTime - entryHrTime) / 1_000_000;

            const returnEvent = {
                type: 'return',
                function: functionName,
                file: fileName,
                filePath: filePath,
                line: lineNum,
                timestamp: Date.now(),
                durationMs: parseFloat(durationMs.toFixed(2)),
                level: _indentLevel,
                isError: threwError,
                returnValue: threwError ? errorDetails : serializeReturnValue(returnValue)
            };
            traceEvent.returnEvent = returnEvent;

            if (_currentMode === TRACER_MODE.REGULAR) {
                if (chalk) {
                    if (threwError) {
                        console.error(chalk.red(`${getIndent()}${EMOJI_ERROR} ${functionName} (${fileName}:${lineNum}), THREW ERROR: ${returnValue.message || returnValue} (took ${durationMs.toFixed(2)}ms)`));
                    } else {
                        console.log(chalk.green(`${getIndent()}${EMOJI_RETURN} ${functionName} (${fileName}:${lineNum}), returned: ${JSON.stringify(returnEvent.returnValue)} (took ${durationMs.toFixed(2)}ms)`));
                    }
                } else {
                    // Fallback without chalk
                     if (threwError) {
                        console.error(`${getIndent()}${EMOJI_ERROR} ${functionName} (${fileName}:${lineNum}), THREW ERROR: ${returnValue.message || returnValue} (took ${durationMs.toFixed(2)}ms)`);
                    } else {
                        console.log(`${getIndent()}${EMOJI_RETURN} ${functionName} (${fileName}:${lineNum}), returned: ${JSON.stringify(returnEvent.returnValue)} (took ${durationMs.toFixed(2)}ms)`);
                    }
                }

            } else if (_currentMode === TRACER_MODE.TEXT) {
                if (threwError) {
                    console.log(`${getIndent()}ERROR ${functionName} (${fileName}:${lineNum}), THREW: ${returnValue.message || returnValue} (took ${durationMs.toFixed(2)}ms)`);
                } else {
                    console.log(`${getIndent()}RETURN ${functionName} (${fileName}:${lineNum}), returned: ${serializeReturnValuePlain(returnValue)} (took ${durationMs.toFixed(2)}ms)`);
                }
            } else if (_currentMode === TRACER_MODE.TREE) {
                const lastCall = _callStack.pop();
                if (lastCall && _callStack.length > 0) {
                    _callStack[_callStack.length - 1].children.push(lastCall);
                }
                const prefix = getTreePrefix(_indentLevel);
                if (chalk) {
                    if (threwError) {
                         _treeLines.push(prefix + chalk.red(`${EMOJI_ERROR} ${functionName} (${fileName}:${lineNum}), THREW ERROR`));
                    } else {
                        _treeLines.push(prefix + chalk.green(`${EMOJI_RETURN} ${functionName} (${fileName}:${lineNum})`));
                    }
                } else {
                     if (threwError) {
                         _treeLines.push(prefix + `${EMOJI_ERROR} ${functionName} (${fileName}:${lineNum}), THREW ERROR`);
                    } else {
                        _treeLines.push(prefix + `${EMOJI_RETURN} ${functionName} (${fileName}:${lineNum})`);
                    }
                }
            }
        }

        if (threwError) {
            throw returnValue; // Re-throw the error after logging
        }
        return returnValue;
    }

    Object.defineProperty(tracedFunction, 'name', { value: functionName });
    return tracedFunction;
}

/**
 * Iterates through an object (e.g., a module) and wraps its functions.
 */
function traceObject(obj, filePath, sourceMap = {}) {
    if (!_enableTracing) return;

    if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
        if (chalk) {
            console.warn(chalk.yellow(`${EMOJI_WARN} [TRACER] Cannot trace non-object/non-function:`, obj));
        } else {
            console.warn(`[TRACER] Cannot trace non-object/non-function:`, obj);
        }
        return;
    }

    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            const originalValue = obj[key];
            const lineNum = sourceMap[key] || 'unknown';

            if (typeof originalValue === 'function') {
                obj[key] = wrapFunction(originalValue, `${key}`, filePath, lineNum);
            }
        }
    }
}

/**
 * Call this function at the end of your application (or when tracing is complete)
 * to output final JSON or Tree view.
 */
function finalizeTracing() {
    if (!_enableTracing) return;

    if (_currentMode === TRACER_MODE.JSON) {
        if (chalk) {
            console.log(chalk.yellow(`${EMOJI_INFO} [TRACER] JSON Trace Output:`));
        } else {
            console.log(`[TRACER] JSON Trace Output:`);
        }
        console.log(JSON.stringify(_traceEvents, null, 2));
    } else if (_currentMode === TRACER_MODE.TREE) {
        if (chalk) {
            console.log(chalk.yellow(`${EMOJI_INFO} [TRACER] Tree Trace Output:`));
        } else {
            console.log(`[TRACER] Tree Trace Output:`);
        }
        _treeLines.forEach(line => console.log(line));
    }
    resetTracer();
}


module.exports = {
    traceObject,
    setMode,
    enableTracing,
    finalizeTracing,
    resetTracer,
    TRACER_MODE
};