const fs = require('fs');
const path = require('path');

class KeolParser {
  constructor(baseDir = '.') {
    this.result = {};
    this.currentSection = this.result;
    this.variables = {};
    this.baseDir = baseDir;

    this.commands = {
      log: args => console.log(this._replaceVars(args)),
      warn: args => console.warn('[WARN]', this._replaceVars(args)),
      error: args => console.error('[ERROR]', this._replaceVars(args)),
      shout: args => console.log('[SHOUTING]', this._replaceVars(args).toUpperCase()),
      eval_javaScript: args => eval(this._replaceVars(args)),
      json: args => {
        try {
          const parsed = JSON.parse(this._replaceVars(args));
          console.log('[JSON_PARSE_SUCCESS]', parsed);
        } catch (e) {
          console.error('[JSON_PARSE_ERROR]', e.message, 'Raw JSON:', args);
        }
      }
    };
  }

  addCommand(name, fn) {
    this.commands[name] = (...args) => {
      const replacedArgs = args.map(arg =>
        typeof arg === 'string' ? this._replaceVars(arg) : arg
      );
      fn(...replacedArgs);
    };
  }

  parse(text, filename = null) {
    const lines = text.split(/\r?\n/);
    let multiKey = null;
    let multiValue = '';
    let multiLineCommand = null;

    for (let raw of lines) {
      const line = raw.trim();
      if (!line || line.startsWith('#')) continue;

      if (line.startsWith('+')) {
        this._includeFile(line.slice(1).trim());
        continue;
      }

      if (line.endsWith('::')) {
        const section = line.slice(0, -2).trim();
        this.result[section] = {};
        this.currentSection = this.result[section];
        continue;
      }

      if (line === ';') {
        this.currentSection = this.result;
        if (multiLineCommand) {
          this._executeCommand(multiLineCommand, multiValue.trim());
          multiLineCommand = null;
          multiValue = '';
        }
        continue;
      }

      if (line.includes(':') && line.includes('|') && line.indexOf('|') > line.indexOf(':')) {
        multiKey = line.split(':')[0].trim();
        multiValue = '';
        if (multiKey.startsWith('~')) {
          multiLineCommand = multiKey.slice(1).trim();
          multiKey = null;
        }
        continue;
      }

      if (multiKey !== null || multiLineCommand !== null) {
        if (line === '|') {
          if (multiKey !== null) {
            this._setKey(multiKey, this._replaceVars(multiValue.trim()));
            multiKey = null;
            multiValue = '';
          }
        } else {
          multiValue += line + '\n';
        }
        continue;
      }

      if (line.startsWith('~') && line.includes(':')) {
        const [cmd, ...rest] = line.slice(1).split(':');
        const args = rest.join(':').trim();
        this._executeCommand(cmd.trim(), args);
        continue;
      }

      if (line.includes(':')) {
        this._parseKeyValue(line);
      }
    }

    if (multiLineCommand) {
      this._executeCommand(multiLineCommand, multiValue.trim());
    }

    return this.result;
  }

  _includeFile(includePath) {
    const fullPath = path.resolve(this.baseDir, includePath);
    if (fs.existsSync(fullPath)) {
      const content = fs.readFileSync(fullPath, 'utf-8');
      this.parse(content, fullPath);
    } else {
      console.warn(`[KEOL] Included file not found: ${fullPath}`);
    }
  }

  _executeCommand(name, args) {
    if (this.commands[name]) {
      this.commands[name](args);
    } else {
      console.warn(`[KEOL] Unknown command: ~${name}`);
    }
  }

  _parseKeyValue(line) {
    const [rawKey, ...rest] = line.split(':');
    let key = rawKey.trim();
    let rawValue = rest.join(':').trim();

    if (key.includes(' ')) {
      const [base, tag] = key.split(/\s+/);
      key = `${base} (${tag})`;
    }

    if (key.startsWith('@')) {
      this._setKey(`@${key.slice(1)}`, rawValue);
      return;
    }

    if (key.startsWith('$')) {
      this.variables[key.slice(1)] = rawValue;
      return;
    }

    let value;
    if (rawValue.startsWith('[') && rawValue.endsWith(']')) {
      value = this._parseArray(rawValue.slice(1, -1));
    } else if (rawValue.startsWith('{') && rawValue.endsWith('}')) {
      value = this._parseObject(rawValue.slice(1, -1));
    } else {
      value = this._replaceVars(rawValue);
    }

    this._setKey(key, value);
  }

  _parseArray(arrayString) {
    const items = [];
    let current = '';
    let bracket = 0;
    let brace = 0;
    let quote = false;

    for (let i = 0; i < arrayString.length; i++) {
      const c = arrayString[i];
      if (c === '"' || c === "'") quote = !quote;
      if (!quote && c === '[') bracket++;
      if (!quote && c === ']') bracket--;
      if (!quote && c === '{') brace++;
      if (!quote && c === '}') brace--;

      if (c === ',' && bracket === 0 && brace === 0 && !quote) {
        items.push(this._parseArrayItem(current.trim()));
        current = '';
      } else {
        current += c;
      }
    }

    if (current.trim()) {
      items.push(this._parseArrayItem(current.trim()));
    }

    return items;
  }

  _parseArrayItem(item) {
    const colonIndex = item.indexOf(':');
    if (colonIndex > 0 && /^[a-zA-Z_][\w-]*\s*:\s*{/.test(item)) {
      const key = item.slice(0, colonIndex).trim();
      const val = item.slice(colonIndex + 1).trim();
      try {
        return { [key]: this._parseValue(val) };
      } catch {
        return item;
      }
    } else {
      return this._parseValue(item);
    }
  }

  _parseObject(objectString) {
    const obj = {};
    let currentPair = '';
    let bracketCount = 0;
    let braceCount = 0;
    let inQuote = false;
    let colonIndex = -1;

    for (let i = 0; i < objectString.length; i++) {
      const char = objectString[i];

      if (char === '"' || char === "'") inQuote = !inQuote;
      else if (char === '[' && !inQuote) bracketCount++;
      else if (char === ']' && !inQuote) bracketCount--;
      else if (char === '{' && !inQuote) braceCount++;
      else if (char === '}' && !inQuote) braceCount--;
      else if (char === ':' && bracketCount === 0 && braceCount === 0 && !inQuote) {
        colonIndex = currentPair.length;
      }

      if (char === ',' && bracketCount === 0 && braceCount === 0 && !inQuote) {
        if (colonIndex !== -1) {
          const key = currentPair.substring(0, colonIndex).trim();
          const valueStr = currentPair.substring(colonIndex + 1).trim();
          obj[this._replaceVars(key)] = this._parseValue(valueStr);
        } else {
          console.warn(`[KEOL_PARSE_WARN] Malformed object pair: ${currentPair}`);
        }
        currentPair = '';
        colonIndex = -1;
      } else {
        currentPair += char;
      }
    }

    if (currentPair.trim() !== '' && colonIndex !== -1) {
      const key = currentPair.substring(0, colonIndex).trim();
      const valueStr = currentPair.substring(colonIndex + 1).trim();
      obj[this._replaceVars(key)] = this._parseValue(valueStr);
    } else if (currentPair.trim() !== '') {
      console.warn(`[KEOL_PARSE_WARN] Malformed object pair at end: ${currentPair}`);
    }

    return obj;
  }

  _parseValue(valueStr) {
    valueStr = valueStr.trim();
    if (valueStr.startsWith('[') && valueStr.endsWith(']')) {
      return this._parseArray(valueStr.slice(1, -1));
    } else if (valueStr.startsWith('{') && valueStr.endsWith('}')) {
      return this._parseObject(valueStr.slice(1, -1));
    } else if (!isNaN(valueStr)) {
      return Number(valueStr);
    } else if (valueStr.toLowerCase() === 'true') {
      return true;
    } else if (valueStr.toLowerCase() === 'false') {
      return false;
    } else {
      return this._replaceVars(valueStr);
    }
  }

  _replaceVars(str) {
    if (typeof str !== 'string') return str;
    return str.replace(/\$([a-zA-Z_]\w*)/g, (_, name) => this.variables[name] ?? `$${name}`);
  }

  _setKey(key, value) {
    this.currentSection[key] = value;
  }
}

module.exports = { KeolParser };